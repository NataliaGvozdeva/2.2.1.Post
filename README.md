#### 2.2. ООП: Объекты и классы

##### Задача №3 - Wall Tests

Куда же без автотестов? Правильно, никуда. Вам нужно написать автотесты на ваши методы:

* на add - всего один, который проверяет, что после добавления поста id стал не равным 0
* на update - целых два:
   * удаляем пост с существующим id, возвращается true
   * удаляем пост с несуществующим id, возвращается false

Вы можете спросить, почему именно так? Почему мы не проверяем, что add действительно добавил, а update действительно что-то меняет?

На самом деле, нам пока совсем немного не хватает знаний, чтобы достроить нашу систему до действительно тестируемой (их мы получим на следующей лекции). Пока же сделаем именно так.

По факту, речь идёт о том, что нам придётся либо дописать специальные вспомогательные методы, либо научиться работать с nullable значениями.

###### Проблемы синглтонов
С синглтонами есть одна большая проблема (почему их и не любят) - они создаются один раз при старте приложения и в единственном экземпляре.

Тестировать такое не всегда удобно: вы либо должны сделать метод, который "вычищает" синглтон, т.е. сбрасывает массив записей, либо переделать object на обычный класс.

Если вы сделаете обычный класс, тогда в каждом тесте вы можете поступить следующим образом (пример для update):
```kotlin
class WallServiceTest {
    @Test
    fun updateExisting() {
        // создаём целевой сервис
        val service = WallService()
        // заполняем несколькими постами 
        service.add(Post(/* заполняете поля */))
        service.add(Post(/* заполняете поля */))
        service.add(Post(/* заполняете поля */))
        // создаём информацию об обновлении
        val update = Post(/* заполняете поля */)

        // выполняем целевое действие
        val result = service.update(update)

        // проверяем результат (используйте assertTrue или assertFalse)
        assertTrue(result)
    }
}
```
Итого, у вас должно быть:

1. У вас должен быть репозиторий на GitHub, в котором расположен ваш Gradle-проект
1. К репозиторию должен быть подключен GitHub Actions
1. Сборка должна быть "зелёной" (значит, ваши тесты должны проходить)
1. Необязательно: попробуйте обеспечить максимальное покрытие тестируемых функций (проанализируйте, какой код в ваших функциях не используйте и почему, по возможности, либо избавьтесь от него, либо допишите автотесты)


##### Задача №2 - Wall

Теперь нужно разобраться с функциональностью сервиса, отвечающего за стены пользователей: https://vk.com/dev/wall (копия).

Нас будут интересовать следующие методы:

1. Создание записи
1. Обновление записи

###### Создание записи
Итак поехали, метод для создания записи должен выглядеть вот так:

```kotlin
    fun add(post: Post): Post {
        TODO()
    }
```
Как он должен работать:

Он должен добавлять запись в массив, но при этом назначать посту уникальный идентификатор (среди всех постов)
Возвращается пост уже с выставленным идентификатором
Подсказка
Обновление записи
Метод для создания записи должен выглядеть вот так:
```kotlin
    fun update(post: Post): Boolean {
        TODO()
    }
```
Как он должен работать:

1. Он должен находить среди всех постов запись с тем же id, что и у post и обновлять все свойства, кроме id владельца и даты создания
1. Если пост с таким id не найден, то ничего не делается и возвращается false, в противном случае - возвращается true

Подсказка
Возможно, вам стоит завести private property для хранения следующего уникального id. Пока у нас in-memory система (всё хранится в оперативной памяти) и всё работает на одной машине, этого будет достаточно.

###### Результаты
Итого, у вас должно быть:

1. У вас должен быть репозиторий на GitHub, в котором расположен ваш Gradle-проект
1. К репозиторию должен быть подключен подключен GitHub Actions
1. В истории должен быть хотя бы один коммит, ломающий сборку

##### Задача №1 - Посты

Наконец мы добрались до ООП и можем уже не только решать вычислительные задачи, но и моделировать целые системы.

На лекции мы разобрали упрощённый пример того, как может выглядеть пост, давайте же посмотрим на то, как он выглядит на самом деле*.

Примечание*: возьмите себе за привычку анализировать системы, с которыми вы работаете в реальной жизни, и продумывать "как бы сделали вы".

В качестве примера возьмём всё тот же VK: https://vk.com/dev/objects/post (если страница у вас по каким-то причинам недоступна, воспользуйтесь [копией](https://github.com/netology-code/kt-homeworks/blob/master/05_objects/assets/post.pdf) из каталога [assets](https://github.com/netology-code/kt-homeworks/tree/master/05_objects/assets)).

На что нужно обратить внимание:

1. В Kotlin мы используем camelCase для полей
1. Некоторые поля помечены как integer [0, 1], хотя по логике, должны быть Boolean (у вас должны быть Boolean)
1. Игнорируйте поля post_source, attachments, geo, copy_history
1. Все остальные поля должны быть перечислены

Что мы хотим получить:

1. Data класс Post
1. Объект WallService, который внутри себя хранит посты в массиве

Итого: у вас должен быть репозиторий на GitHub, в котором расположен ваш Gradle-проект (автотесты также должны храниться в репозитории).